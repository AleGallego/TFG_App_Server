generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model alumnos {
  id                 Int                  @id @default(autoincrement())
  alumno             String               @db.VarChar(100)
  dni                String               @unique @db.VarChar(20)
  correo             String               @unique(map: "alumnos_email_key") @db.VarChar(100)
  telefono           String?              @db.VarChar(20)
  fecha_ingreso      DateTime             @db.Date
  matricula_activa   Boolean?             @default(true)
  uo                 String               @db.VarChar(8)
  contraseña        String?              @db.VarChar(400)
  historial_grupo    historial_grupo[]
  matricula          matricula[]
  mensajes           mensajes[]
  nota               nota[]
  tutorias           tutorias[]
  PasswordResetToken passwordresettoken[]
  revision_alumno revision_alumno[] @relation(map: "fk_alumno")
}

model asignaturas {
  id              Int               @id(map: "Asignatura_pkey") @default(autoincrement())
  nombre          String
  descripci_n     String?           @map("descripción")
  cr_ditos        Int               @map("créditos")
  curso           Int
  semestre        Int
  horas_teor_a    Float?            @map("horas_teoría")
  horas_pr_cticas Float?            @map("horas_prácticas")
  matricula       matricula[]
  tablon_anuncios tablon_anuncios[]
  clases          clases[]
  grupo           grupo[]
}

model grupo {
  id              Int               @id @default(autoincrement())
  nombre          String
  id_asignatura   Int
  matricula       matricula[]
  grupo_clases    grupo_clases[]
  historial_grupo historial_grupo[] @relation(map: "fk_grupo_historial")
  asignatura      asignaturas       @relation(fields: [id_asignatura], references: [id], onDelete: Cascade)

  @@unique([nombre, id_asignatura])
}

model clases {
  id              Int               @id @default(autoincrement())
  tipo            String
  nombre          String
  id_asignatura   Int
  id_profesor     Int?
  asignaturas     asignaturas       @relation(fields: [id_asignatura], references: [id], onDelete: Cascade)
  profesores      profesores?       @relation(fields: [id_profesor], references: [id], onDelete: Cascade)
  grupo_clases    grupo_clases[]
  tablon_anuncios tablon_anuncios[] @relation(map: "fk_clases_anuncio")
  pruebas         pruebas[]         @relation(map: "fk_clase_prueba")

  @@unique([tipo, nombre, id_asignatura])
}

model grupo_clases {
  id_grupo  Int
  id_clases Int
  grupo     grupo  @relation(fields: [id_grupo], references: [id], onDelete: Cascade)
  clases    clases @relation(fields: [id_clases], references: [id], onDelete: Cascade)

  @@id([id_grupo, id_clases])
  @@map("grupo_clases")
}

model historial_grupo {
  id         Int       @id @default(autoincrement())
  fecha_ini  DateTime  @db.Date
  fecha_fin  DateTime? @db.Date
  comentario String?
  id_alumno  Int
  id_grupo   Int
  alumnos    alumnos   @relation(fields: [id_alumno], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_alumno_historial")
  grupo      grupo     @relation(fields: [id_grupo], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_grupo_historial")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model horario_tutoria {
  id          Int        @id @default(autoincrement())
  dia         Int
  hora_ini    DateTime   @db.Time(6)
  hora_fin    DateTime   @db.Time(6)
  id_profesor Int
  profesores  profesores @relation(fields: [id_profesor], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_profesor_horario")
}

model matricula {
  id_alumno               Int
  id_asignatura           Int
  curso_academico         String?     @db.VarChar(9)
  convocatorias           Int?        @default(0)
  nota_final              Float?
  nota_alfabetica         String?     @db.VarChar(50)
  nota_actual             Float?
  evaluacion_diferenciada String      @db.VarChar(2)
  movilidad_erasmus       String      @db.VarChar(2)
  id_grupo                Int?
  matriculas              Int
  superada                Boolean     @default(false)
  alumnos                 alumnos     @relation(fields: [id_alumno], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_alumno_matricula")
  asignaturas             asignaturas @relation(fields: [id_asignatura], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_asignatura_matricula")
  grupo                   grupo?      @relation(fields: [id_grupo], references: [id], onDelete: NoAction, onUpdate: Cascade, map: "fk_grupo_matricula")

  @@id([id_alumno, id_asignatura], map: "pk_matricula")
}

model mensajes {
  id          Int         @id @default(autoincrement())
  mensaje     String
  fecha       DateTime    @default(now()) @db.Timestamp(6)
  emisor      Int
  id_alumno   Int?
  id_profesor Int?
  alumnos     alumnos?    @relation(fields: [id_alumno], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_alumno_mensaje")
  profesores  profesores? @relation(fields: [id_profesor], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_profesor_mensaje")
}

model nota {
  id        Int     @id @default(autoincrement())
  nota      Float
  id_alumno Int
  id_prueba Int
  alumnos   alumnos @relation(fields: [id_alumno], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_alumno_nota")
  pruebas   pruebas @relation(fields: [id_prueba], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_prueba_nota")

  @@unique([id_alumno, id_prueba]) // esto asegura que un alumno solo tiene una nota por prueba
}

model profesores {
  id                 Int                  @id(map: "profesor_pkey") @default(autoincrement())
  nombre             String               @db.VarChar(100)
  apellidos          String               @db.VarChar(150)
  correo             String               @unique(map: "profesor_correo_key") @db.VarChar(120)
  telefono           String?              @db.VarChar(20)
  departamento       String?              @db.VarChar(100)
  contraseña        String?              @db.VarChar(400)
  horario_tutoria    horario_tutoria[]
  mensajes           mensajes[]
  tablon_anuncios    tablon_anuncios[]
  tutorias           tutorias[]
  clases             clases[]
  passwordresettoken passwordresettoken[]
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model pruebas {
  id                 Int       @id(map: "prueba_pkey") @default(autoincrement())
  nombre             String    @db.VarChar(100)
  nota_minima        Float?
  peso               Float?
  fecha_entrega      DateTime? @db.Date
  fecha_modificacion DateTime? @db.Date
  id_clase           Int
  nota               nota[]
  clases             clases    @relation(fields: [id_clase], references: [id], onDelete: NoAction, onUpdate: Cascade, map: "fk_clase_prueba")
  revision revision[] @relation(map: "fk_revision_prueba")
}

model tablon_anuncios {
  id            Int          @id @default(autoincrement())
  titulo        String       @db.VarChar(150)
  contenido     String
  id_asignatura Int?
  id_clase      Int?
  id_profesor   Int?
  createdAt     DateTime     @default(now()) // <-- fecha de creación automática
  asignaturas   asignaturas? @relation(fields: [id_asignatura], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_asignatura_anuncio")
  clases        clases?      @relation(fields: [id_clase], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_clases_anuncio")
  profesores    profesores?  @relation(fields: [id_profesor], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_profesor_anuncio")
}

model tutorias {
  id          Int        @id @default(autoincrement())
  motivo      String     @db.VarChar(200)
  fecha       DateTime   @db.Date
  hora_ini    DateTime   @db.Time(6)
  hora_fin    DateTime   @db.Time(6)
  id_profesor Int
  id_alumno   Int
  aceptada    Boolean
  alumnos     alumnos    @relation(fields: [id_alumno], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_alumno")
  profesores  profesores @relation(fields: [id_profesor], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_profesor")
}

model passwordresettoken {
  id          Int         @id @default(autoincrement())
  id_alumno   Int?        @unique
  id_profesor Int?        @unique
  tokenHash   String // Guardamos el hash del token, nunca en plano
  expiresAt   DateTime // Fecha de caducidad
  createdAt   DateTime    @default(now())
  alumnos     alumnos?    @relation(fields: [id_alumno], references: [id], onDelete: Cascade)
  profesores  profesores? @relation(fields: [id_profesor], references: [id], onDelete: Cascade)

  @@index([id_alumno]) // para buscar rápido por usuario
}

model revision {
  id          Int        @id @default(autoincrement())
  motivo      String     @db.VarChar(200)
  fecha       DateTime   @db.Date
  hora_ini    DateTime   @db.Time(6)
  hora_fin    DateTime   @db.Time(6)
  id_prueba   Int
  prueba      pruebas    @relation(fields: [id_prueba], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_revision_prueba")
  revision_alumno revision_alumno[]
}

model revision_alumno {
  id_revision Int
  id_alumno   Int
  revision    revision   @relation(fields: [id_revision], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_revision")
  alumnos     alumnos    @relation(fields: [id_alumno], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_alumno")
  @@id([id_revision, id_alumno])
}
